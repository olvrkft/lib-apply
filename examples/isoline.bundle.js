/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./lib/FastContourTracer.js":
/*!**********************************!*\
  !*** ./lib/FastContourTracer.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lib_ImageMatrix_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/ImageMatrix.js */ \"./lib/ImageMatrix.js\");\n/* harmony import */ var _lib_ImageMatrix_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_ImageMatrix_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n\nconst SAME      = 0;\nconst FRONT     = 1;\nconst FRONTLEFT = 2;\nconst LEFT      = 3;\nconst LEFTREAR  = 4;\n\nconst END_NOT          = 0;\nconst END_REACHEDSTART = 1;\nconst END_IDLE         = 2;\n\nconst TRACED = 0x0000CCFF;\n\n/**\n * Objects grants access to the neighbour pixels depending to the tracers\n *  current direction.\n *\n * Direction to position translation table:\n * -----------\n * | N3 | N4 | N3: front-left, N4: front\n * -----------\n * | N2 | N0 | N2: left, N0: tracer-position\n * -----------\n * | N1 |    | N1: rear-left\n * -----------\n * (northern direction)\n *\n * @see \"Fast Contour-Tracing Algorithm Based on a Pixel-Following Method for\n *       Image Sensors\" (Seo ETAL, 11, 2016)\n */\nlet DIRECTION = {\n  0:  { N1: {x:-1,y: 1}, N2: {x:-1,y: 0}, N3: {x:-1,y:-1}, N4: {x: 0,y:-1} }, // N\n  1:  { N1: {x:-1,y:-1}, N2: {x: 0,y:-1}, N3: {x: 1,y:-1}, N4: {x: 1,y: 0} }, // E\n  2:  { N1: {x: 1,y:-1}, N2: {x: 1,y: 0}, N3: {x: 1,y: 1}, N4: {x: 0,y: 1} }, // S\n  3:  { N1: {x: 1,y: 1}, N2: {x: 0,y: 1}, N3: {x:-1,y: 1}, N4: {x:-1,y: 0} }  // W\n}\n\n/**\n *\n */\nclass FastContourTracer\n{\n  /**\n   * Constructor\n   * @param  {ImageMatrix,ImageData} data  [description]\n   * @param  {Number} tracingColor [description]\n   */\n  constructor(data, tracingColor)\n  {\n    let size   = null\n      , matrix = null;\n\n    // Create a copy of clampedArray, since tracer manipulates data.\n    if (data instanceof ImageData)\n    {\n      matrix = new (_lib_ImageMatrix_js__WEBPACK_IMPORTED_MODULE_0___default())(data.data);\n    }\n    else if (data instanceof (_lib_ImageMatrix_js__WEBPACK_IMPORTED_MODULE_0___default()))\n    {\n      matrix = new (_lib_ImageMatrix_js__WEBPACK_IMPORTED_MODULE_0___default())( new ImageData(data.imageData.data.slice(0),\n                                              data.imageData.width,\n                                              data.imageData.height) );\n    }\n    else {\n      throw new Error(\"[ImageMatrix] First argument must be an instance of ImageData\");\n    }\n\n    this.i            = 0;\n    this.d            = 1;               // key for the current DIRECTION\n    this.idle         = 0;               // Count idle iterations.\n    this.end          = END_NOT;         // State of the end condition.\n    this.start        = {'x': 0, 'y': 0};\n    this.position     = {'x': 0, 'y': 0};\n    this.imageMatrix  = matrix;\n    this.tracingColor = tracingColor;\n  }\n\n  /**\n   * Create paths.\n   * @return {Array} Array containing arrays of numbers.\n   */\n  createPaths()\n  {\n    let path\n      , start\n      , paths = [];\n\n    while (null !== (start = this.nextStart())) {\n      paths.push( this.createPath(start) );\n    }\n\n    return paths;\n  }\n\n  /**\n   * Get the next starting point for the tracing algorithm.\n   * @return {Object} Return an object containing the starting position ({x,y}).\n   */\n  nextStart()\n  {\n    let c\n      , x\n      , y = this.start.y\n      , position = null\n      , matrix   = this.imageMatrix;\n\n    // Looking direction is always 1 (east).\n    this.d = 1;\n\n    for ( ; y < matrix.height - 1; ++y) {\n      for (x = 0; x < matrix.width - 1; ++x)\n      {\n        c = matrix.get(x, y);\n        if (c === this.tracingColor) {\n          if (this.tracingColor !== this.leftRearValue) // check if neighbours are not left-rear inner-outer colored\n          {\n            position = {\"x\": x, \"y\": y};\n            break;\n          }\n        }\n      }\n\n      // Do not iterate, if a starting position is reached.\n      if (null !== position)\n      {\n        this.start.x = position.x;\n        this.start.y = position.y;\n        break;\n      }\n    }\n\n    return position;\n  }\n\n  /**\n   *\n   */\n  createPath(start)\n  {\n    let result = {'path': null, 'closed': true}\n      , path   = [];\n\n    // Reset i and end condition.\n    this.i    = 0;\n    this.idle = 0;\n    this.end  = END_NOT;\n\n    // Set current position to starting position.\n    this.position.x = start.x;\n    this.position.y = start.y;\n\n    do\n    {\n      // Stage 1\n      if (this.leftRearValue === this.tracingColor) {\n        if (this.leftValue === this.tracingColor) {\n          // Case 1\n          // T(P,d) <- T(P_left, d_left) and code(i) <- \"inner\"\n          // T(P,d) <- T(P_left, d_left)\n          //console.log('(C1) inner');\n          this.update(LEFT, this.leftDirection, path);\n          this.update(LEFT, this.leftDirection, path);\n        } else {\n          // Case 2\n          // code(i) <- \"inner-outer\"\n          // T(P,d) <- T(P_left-rear, d_rear) and Code(i) <- \"inner-outer\"\n          //console.log('(C2) inner-outer', this.d);\n          this.update(LEFTREAR , this.rearDirection, path);\n        }\n      }\n      else {\n        if (this.leftValue === this.tracingColor) {\n          // Case 3\n          // T(P,d) <- T(P_left, d_left) and code(i) <- \"straight\"\n          //console.log('(C3) straight');\n          this.update(LEFT, this.leftDirection, path);\n        } else {\n          // Case 4\n          // code(i) <- \"outer\"\n          //console.log('(C4) outer');\n          this.idle += 1;\n        }\n      }\n\n      // Stage 2\n      if (this.frontLeftValue === this.tracingColor) {\n        if (this.frontValue === this.tracingColor) {\n          // Case 6\n          // T(P,d) <- T(P_front, d_left) and code(i) <- \"inner\"\n          // T(P,d) <- T(P_front, d_right)\n          //console.log('(C6) inner');\n          this.update(FRONT, this.leftDirection, path);\n          this.update(FRONT, this.rightDirection, path);\n        } else {\n          // Case 5\n          // T(P,d) <- T(P_front-left, d) and code(i) <- \"inner-outer\"\n          //console.log('(C5) inner-outer');\n          this.update(FRONTLEFT, this.d, path);\n        }\n      }\n      else if (this.frontValue === this.tracingColor) {\n        // Case 7\n        // T(P,d) <- T(P_front, d_right)\n        //console.log('(C7) no code');\n        this.update(FRONT, this.rightDirection, path);\n      }\n      else {\n        // Case 8\n        // T(P,d) <- T(P,d_rear) and i <- i - 1 and code(i) <- \"outer\"\n        //console.log('(C8) outer :', this.d);\n        this.update(SAME, this.rearDirection);\n      }\n    }\n    while ( !(this.end = this.doStop(start)) );\n\n    // Add last postion to the path, if end condition is idle ending.\n    if (END_IDLE === this.end)\n    {\n      result.closed = false;\n\n      path.push(this.position.x);\n      path.push(this.position.y);\n\n      // Set the starting position to traced to avoid endless iterations.\n      this.imageMatrix.set(start.x, start.y, TRACED);\n    }\n\n    if (path.length < 3) {\n      this.imageMatrix.set(this.position.x, this.position.y, 0xCC00CCFF);\n    }\n\n    result.path = path;\n\n    return result;\n  }\n\n  /**\n   * Update position (p) and direction (d). Positon altered to SAME, FRONT, LEFT\n   *  and LEFTREAR.\n   * @param  {const} p Constant indicating the moving direction.\n   * @param  {Number} d New looking direction.\n   * @param  {Array} path Array containing x- and y-coords.\n   */\n  update(p, d, path)\n  {\n    let move;\n\n    // Get position malipulators.\n    if (FRONT === p) {\n      move = DIRECTION[this.d].N4;\n    }\n    else if (FRONTLEFT === p) {\n      move = DIRECTION[this.d].N3;\n    }\n    else if (LEFT === p) {\n      move = DIRECTION[this.d].N2;\n    }\n    else if (LEFTREAR === p) {\n      move = DIRECTION[this.d].N1;\n    }\n\n    // Update position\n    if (SAME === p)\n    {\n      this.i    -= 1;\n      this.idle += 1;\n    }\n    else {\n      this.idle = 0;\n\n      path[this.i * 2]     = this.position.x;\n      path[this.i * 2 + 1] = this.position.y;\n\n      this.position.x += move.x;\n      this.position.y += move.y;\n    }\n\n    // Set new direction after updating position.\n    this.d = d;\n\n    // Update iteration counter.\n    this.i += 1;\n\n    if (this.i > 0) {\n      this.imageMatrix.set(this.position.x, this.position.y, TRACED);\n    }\n  }\n\n  /**\n   * Indicates to stop the algorithm if starting position is reached or if the\n   *  if counter exceeds 2 idle iterations.\n   * @param  {Object} start Contains starting position {x,y}.\n   * @return {Boolean}      Indicates whether to stop or not.\n   */\n  doStop(start)\n  {\n    let result = END_NOT;\n\n    // Check if starting position is reached.\n    if (this.position.x === start.x &&\n        this.position.y === start.y &&\n        this.i > 1)\n    {\n      result = END_REACHEDSTART;\n    }\n\n    // Check if position did not change for more than 2 iterations.\n    if (this.idle > 2) {\n      result = END_IDLE;\n    }\n\n    return result;\n  }\n\n  /**\n   * Get tracers current position RGBA value.\n   * @return {Number} Number representing the 32-bit color of the pixel\n   */\n  get currentValue() {\n    return this.imageMatrix.get(this.position.x, this.position.y);\n  }\n\n  /**\n   * Get front RGBA value.\n   * @return {Number} Number representing the 32-bit color of the pixel\n   */\n  get frontValue()\n  {\n    let x = this.position.x + this.direction.N4.x\n      , y = this.position.y + this.direction.N4.y;\n\n    return this.imageMatrix.get(x, y);\n  }\n\n  /**\n   * Get front-left RGBA value.\n   * @return {Number} Number representing the 32-bit color of the pixel\n   */\n  get frontLeftValue()\n  {\n    let x = this.position.x + this.direction.N3.x\n      , y = this.position.y + this.direction.N3.y;\n\n    return this.imageMatrix.get(x, y);\n  }\n\n  /**\n   * Get left RGBA value.\n   * @return {Number} Number representing the 32-bit color of the pixel\n   */\n  get leftValue()\n  {\n    let x = this.position.x + this.direction.N2.x\n      , y = this.position.y + this.direction.N2.y;\n\n    return this.imageMatrix.get(x, y);\n  }\n\n  /**\n   * Get left-rear RGBA value.\n   * @return {Number} Number representing the 32-bit color of the pixel\n   */\n  get leftRearValue()\n  {\n    let x = this.position.x + this.direction.N1.x\n      , y = this.position.y + this.direction.N1.y;\n\n    return this.imageMatrix.get(x, y);\n  }\n\n  /**\n   * Current directional object with manipulators for N0...N4\n   * @return {Object} Containing directional manipulator values.\n   */\n  get direction() {\n    return DIRECTION[this.d];\n  }\n\n  /**\n   * The current front directional key.\n   * @return {Number} Number from [0...3].\n   */\n  get frontDirection() {\n    return this.d;\n  }\n\n  /**\n   * The current right directional key.\n   * @return {Number} Number from [0...3].\n   */\n  get rightDirection() {\n    return (this.d + 1) & 0b11;\n  }\n\n  /**\n   * The current rear directional key.\n   * @return {Number} Number from [0...3].\n   */\n  get rearDirection() {\n    return (this.d + 2) & 0b11;\n  }\n\n  /**\n   * The current left directional key.\n   * @return {Number} Number from [0...3].\n   */\n  get leftDirection() {\n    return (this.d - 1) & 0b11;\n  }\n}\n\n// -----------------------------------------------------------------------------\n//\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FastContourTracer);\n\n\n//# sourceURL=webpack://lib-apply/./lib/FastContourTracer.js?");

/***/ }),

/***/ "./lib/ImageMatrix.js":
/*!****************************!*\
  !*** ./lib/ImageMatrix.js ***!
  \****************************/
/***/ ((module) => {

eval("\r\nconst WORD = 4;\r\n\r\n/**\r\n * Wrapper around ImageData object to grant easy access.\r\n */\r\nclass ImageMatrix\r\n{\r\n  /**\r\n   * Constructor.\r\n   * @param  {ImageData} imageData ImageData object to be wrapped.\r\n   */\r\n  constructor(imageData)\r\n  {\r\n    if (! (imageData instanceof ImageData)) {\r\n      throw new Error(\"[ImageMatrix] First argument must be an instance of ImageData\");\r\n    }\r\n\r\n    this.imageData = imageData;\r\n    this.data      = this.imageData.data;\r\n  }\r\n\r\n  /**\r\n   * Word width for a pixel in the Uint8ClampedArray.\r\n   */\r\n  static WORD() {\r\n    return WORD;\r\n  }\r\n\r\n  /**\r\n   * Getter for the image width.\r\n   * @return {Number} Width of the image.\r\n   */\r\n  get width() {\r\n    return this.imageData.width;\r\n  }\r\n\r\n  /**\r\n   * Getter for the image height.\r\n   * @return {Number} Height of the image.\r\n   */\r\n  get height() {\r\n    return this.imageData.height;\r\n  }\r\n\r\n  /**\r\n   * Get an 32bit integer for\r\n   * @param  {Number} x x-coords of the pixel.\r\n   * @param  {Number} y y-coords of the pixel.\r\n   * @return {Number}   32bit color.\r\n   */\r\n  get(x, y)\r\n  {\r\n   let i;\r\n\r\n   if (x > this.width - 1 || y > this.height - 1) {\r\n     throw new Error(\"[ImageMatrix] Coords out of image dimensions.\");\r\n   }\r\n\r\n   i = x * WORD + y * this.width * WORD;\r\n\r\n   return ( (this.data[i] * (1 << 24)) + // R\r\n            (this.data[i + 1] << 16) +   // G\r\n            (this.data[i + 2] <<  8) +   // B\r\n            (this.data[i + 3] <<  0) );  // A\r\n  }\r\n\r\n  /**\r\n   * Getter for specified coordinates in the Uint8ClampedArray.\r\n   * @param  {Number} x [description]\r\n   * @param  {Number} y [description]\r\n   * @return {Number} [description]\r\n   */\r\n  getArray(x, y)\r\n  {\r\n    let i;\r\n\r\n    if (x > this.width - 1 || y > this.height - 1) {\r\n      throw new Error(\"[ImageMatrix] Coords out of image dimensions.\");\r\n    }\r\n\r\n    i = x * WORD + y * this.width * WORD;\r\n\r\n   \treturn [ this.data[i],\r\n             this.data[i + 1],\r\n             this.data[i + 2],\r\n             this.data[i + 3] ];\r\n  }\r\n\r\n  /**\r\n   * Setter for specified coordingates int the Uint8ClampedArray.\r\n   *  If r,g and b are set they are interpreted as 8bit values and set. If only\r\n   *  r is set r is interpreted as 32bit value, containing r,g,b,a informations.\r\n   * @param {Number} x X coordingate.\r\n   * @param {Number} y Y coordingate.\r\n   * @param {Number} r 8-Bit color value or 32-Bit value.\r\n   * @param {Number} g 8-Bit color value.\r\n   * @param {Number} b 8-Bit color value.\r\n   * @param {Number} [a=255] [description]\r\n   */\r\n  set(x, y, r, g, b, a = 255)\r\n  {\r\n    let i = x * WORD + y * this.width * WORD;\r\n\r\n    if (undefined === g && undefined === b)\r\n    {\r\n     this.data[i]     = r >>> 24 & 0xFF;\r\n     this.data[i + 1] = r >>> 16 & 0xFF;\r\n     this.data[i + 2] = r >>>  8 & 0xFF;\r\n     this.data[i + 3] = r >>>  0 & 0xFF;\r\n    }\r\n    else {\r\n      this.data[i]     = r;\r\n      this.data[i + 1] = g;\r\n      this.data[i + 2] = b;\r\n      this.data[i + 3] = a;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get x value for a specified data index.\r\n   * @param  {Number} n Data index.\r\n   * @return {Number} Corresponding x-coord for a data index.\r\n   */\r\n  x(n) {\r\n    return Math.floor( (n % this.width) / WORD );\r\n  }\r\n\r\n  /**\r\n   * Get y\r\n   * @param  {Number} n Data index.\r\n   * @return {Number}   Corresponding y-coord for a data index.\r\n   */\r\n  y(n) {\r\n    return Math.floor( n / (this.width * WORD) );\r\n  }\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n//\r\nmodule.exports = ImageMatrix;\r\n\n\n//# sourceURL=webpack://lib-apply/./lib/ImageMatrix.js?");

/***/ }),

/***/ "./lib/Isoline.js":
/*!************************!*\
  !*** ./lib/Isoline.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lib_ImageMatrix_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/ImageMatrix.js */ \"./lib/ImageMatrix.js\");\n/* harmony import */ var _lib_ImageMatrix_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_ImageMatrix_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_FastContourTracer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/FastContourTracer.js */ \"./lib/FastContourTracer.js\");\n\r\n\r\n\r\n\r\n\r\nconst BORDER_POINT   = 0xAA0000FF;\r\nconst JUNCTION_POINT = 0x0000CCFF;\r\n\r\n/**\r\n * Trace regions of an image into its subpixel representation.\r\n * @param  {ImageMatrix} matrix [description]\r\n * @param  {ImageMatrix} subpixel  [description]\r\n * @param  {Number} threshold [description]\r\n * @see Tolga Birdal, Emrah Bala: \"A Novel Method for Vectorization\", 2014, https://arxiv.org/abs/1403.0728v1.\r\n */\r\nlet traceRegions = function(image, subpixel, threshold = 0)\r\n{\r\n  let x, y;\r\n  let p0, p1;\r\n  let I = image;\r\n  let S = subpixel;\r\n  let t = ( (threshold * (1 << 24)) + // R: Create a number that exceeds negative boundaries.\r\n            (threshold << 16) +       // G\r\n            (threshold <<  8) +       // B\r\n            (threshold <<  0) );      // A\r\n\r\n  for (y = 0; y < S.height - 1; ++y) {\r\n    for (x = 0; x < S.width - 1; ++x)\r\n    { // Calculate regional boundaries.\r\n      if ( (1 === (x % 2) && 0 === (y % 2)) )                  // if (x is odd and y is even) and\r\n      {                                                        //\r\n        p0 = I.get((x + 1)/2, y/2);\r\n        p1 = I.get((x - 1)/2, y/2);\r\n\r\n        if ( p0 !== p1 && (p0 > t || p1 > t) )                 // if (I((x + 1)/2, y/2) !==\r\n        {                                                      //     I((x - 1)/2, y/2)) )\r\n          S.set(x, y, BORDER_POINT);                           //  S(x, y) = 1\r\n        }                                                      //\r\n      }                                                        // or\r\n      if ( (0 === (x % 2) && 1 === (y % 2)) )                  // if (x is even and y is odd) and\r\n      {                                                        //\r\n        p0 = I.get(x/2, (y + 1)/2);\r\n        p1 = I.get(x/2, (y - 1)/2);\r\n\r\n        if ( p0 !== p1 && (p0 > t || p1 > t) )                 // if (I(x/2, (y + 1)/2) !==\r\n        {                                                      //     I(x/2, (y - 1)/2) )\r\n          S.set(x, y, BORDER_POINT);                           //  S(x, y) = 1\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Fix missing boundary values and add junction points.\r\n  for (y = 1; y < S.height - 1; y += 2) {\r\n    for (x = 1; x < S.width - 1; x += 2)\r\n    {\r\n      if (S.get(x + 1, y) === BORDER_POINT && S.get(x - 1, y) === BORDER_POINT ||\r\n          S.get(x, y + 1) === BORDER_POINT && S.get(x, y - 1) === BORDER_POINT)\r\n      {\r\n        if (S.get(x + 1, y) + S.get(x - 1, y) +\r\n            S.get(x, y + 1) + S.get(x, y - 1) > BORDER_POINT * 2) // must be higher than 2 border points\r\n        {\r\n          //S.set(x, y, JUNCTION_POINT);\r\n        } else {\r\n          S.set(x, y, BORDER_POINT);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Creats a black/white image for the tracer.\r\n * @param  {Image} image      Image object.\r\n * @param  {Number} threshold Threshold\r\n * @return {Image}            Manipulated image.\r\n */\r\nlet thresholdRegion = function(image, threshold)\r\n{\r\n  let x, y;\r\n  let black = 0x000000FF, white = 0xFFFFFFFF;\r\n  let I = image;\r\n  let t = ( (threshold * (1 << 24)) + // R: Create a number that exceeds negative boundaries.\r\n            (threshold << 16) +       // G\r\n            (threshold <<  8) +       // B\r\n            0xFF );      // A\r\n\r\n  for (y = 0; y < I.height - 1; ++y) {\r\n    for (x = 0; x < I.width - 1; ++x)\r\n    {\r\n      if (I.get(x, y) > t) {\r\n        I.set(x, y, white);\r\n      } else {\r\n        I.set(x, y, black);\r\n      }\r\n    }\r\n  }\r\n\r\n  return image;\r\n}\r\n\r\n/**\r\n * Converts an image to isolines.\r\n */\r\nclass Isoline\r\n{\r\n  /**\r\n   * Constructor.\r\n   * @param  {Image} image Image to convert.\r\n   */\r\n  constructor(image)\r\n  {\r\n    console.log(\"[Isoline] Creating Isolines.\");\r\n\r\n    this.paths     = null;\r\n    this.image     = null;\r\n    this.imageData = null;\r\n    this.canvas    = null;\r\n\r\n    if (image) {\r\n      this.fromImage(image);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the image to convert. Triggers conversion algorithms.\r\n   */\r\n  fromImage(imageElement, level = 128)\r\n  {\r\n    let context, image, subpixel;\r\n    let tile = {\r\n      'level': {},\r\n      'width':  0,\r\n      'height': 0\r\n    };\r\n\r\n    if (! (imageElement instanceof Image)) {\r\n      throw new Error(\"[Isoline] Argument is not an Image.\");\r\n    }\r\n\r\n    this.canvas = document.createElement('canvas');\r\n    this.canvas.width  = imageElement.width;\r\n    this.canvas.height = imageElement.height;\r\n\r\n    context = this.canvas.getContext('2d');\r\n    context.drawImage(imageElement, 0, 0);\r\n\r\n    // Get image data.\r\n    this.imageData = context.getImageData(0, 0, imageElement.width,\r\n                                                imageElement.height);\r\n\r\n    this.image = new (_lib_ImageMatrix_js__WEBPACK_IMPORTED_MODULE_0___default())(this.imageData); // Image matrix of the original image.\r\n\r\n    image    = this.image;\r\n    image    = thresholdRegion(image, level);\r\n    subpixel = this.toSubpixelMatrix(image);\r\n\r\n    traceRegions(image, subpixel);\r\n    this.paths = this.traceContours(subpixel);\r\n\r\n    tile.width        = image.width;\r\n    tile.height       = image.height;\r\n    tile.level[level] = this.paths;\r\n\r\n    this.S = subpixel;\r\n\r\n    this.createCanvas(this.S.imageData);\r\n  }\r\n\r\n  /**\r\n   * Stretch image data to get subpixels.\r\n   * @param  {ImageData} imageData Original image data.\r\n   * @return {ImageData}           Delated image data.\r\n   */\r\n  toSubpixelMatrix(matrix)\r\n  {\r\n    let i, j, k\r\n      , data     = matrix.data\r\n      , width    = matrix.width  * 2\r\n      , height   = matrix.height * 2\r\n      , subpixel = new (_lib_ImageMatrix_js__WEBPACK_IMPORTED_MODULE_0___default())(new ImageData(width, height));\r\n\r\n    for (i = 0; i < data.length; i += 4)\r\n    {\r\n      k = Math.floor(i / (matrix.width * 4)) * (width * 4); // row\r\n      j = (i * 2); // column\r\n\r\n      subpixel.data[k + j]     = data[i];\r\n      subpixel.data[k + j + 1] = data[i + 1];\r\n      subpixel.data[k + j + 2] = data[i + 2];\r\n      subpixel.data[k + j + 3] = data[i + 3];\r\n    }\r\n\r\n    return subpixel;\r\n  }\r\n\r\n  /**\r\n   * Create a subpixel image.\r\n   * @param  {ImageData} data Image to create a subpixel representation from.\r\n   * @return {Array}     Array containing a Uint32Arrays representing subpixel data.\r\n   */\r\n  convertTo32BitArray(imageData)\r\n  {\r\n    // Convert from Uint8ClampedArray to Array/Uint32Array.\r\n    let i, j, k;\r\n    let width  = imageData.width\r\n      , height = imageData.height\r\n      , data   = new Array( height );\r\n\r\n    for (i = 0; i < data.length; ++i) {\r\n      data[i] = new Uint32Array(width);\r\n    }\r\n\r\n    for (i = 0; i < height; ++i)\r\n    {\r\n      for (j = 0; j < width; ++j)\r\n      {\r\n        k = (i * 4 * (width - 1)) + (j * 4);\r\n\r\n        // Create 32bit raw data array.\r\n        data[i][j] = imageData.data[k]     << 24 |  // R\r\n                     imageData.data[k + 1] << 16 |  // G\r\n                     imageData.data[k + 2] <<  8 |  // B\r\n                     imageData.data[k + 3] <<  0;   // A\r\n      }\r\n    }\r\n\r\n    return data;\r\n  }\r\n\r\n  /**\r\n   * Convert data into ImageData obejct.\r\n   * @param  {Array} data [description]\r\n   * @return {ImageData}  Data converted to an ImageData object.\r\n   */\r\n  dataToImageData(data, width, height)\r\n  {\r\n    let i, j, k;\r\n    let clampedArray = new Uint8ClampedArray(width * height * 4);\r\n\r\n    for (i = 0; i < height; ++i)\r\n    {\r\n      for (j = 0; j < width; ++j)\r\n      {\r\n        k = (i * 4 * (width - 1)) + (j * 4);\r\n\r\n        clampedArray[k]     = data[i][j] >> 24 & 0x000000FF;\r\n        clampedArray[k + 1] = data[i][j] >> 16 & 0x000000FF;\r\n        clampedArray[k + 2] = data[i][j] >>  8 & 0x000000FF;\r\n        clampedArray[k + 3] = data[i][j] >>  0 & 0x000000FF;\r\n      }\r\n    }\r\n\r\n    return new ImageData(clampedArray, width, height);\r\n  }\r\n\r\n  /**\r\n   * [subpixelToImageData description]\r\n   * @return {ImageData} ImageData object containing image data from subpixels.\r\n   */\r\n  subpixelToImageData()\r\n  {\r\n    let i;\r\n    let data   = this.subpixel;\r\n    let width  = 2 * this.imageData.width  - 1;\r\n    let height = 2 * this.imageData.height - 1;\r\n    let clampedArray = new Uint8ClampedArray( width * height * 4 );\r\n\r\n    for (i = 0; i < data.length; ++i)\r\n    {\r\n      clampedArray[i * 4]     = data[i] >> 24 & 0xFF;\r\n      clampedArray[i * 4 + 1] = data[i] >> 16 & 0xFF;\r\n      clampedArray[i * 4 + 2] = data[i] >>  8 & 0xFF;\r\n      clampedArray[i * 4 + 3] = data[i] >>  0 & 0xFF;\r\n    }\r\n\r\n    this.imageData = new ImageData(clampedArray, width, height);\r\n  }\r\n\r\n  /**\r\n   * Trace contours.\r\n   * @param  {ImageMatrix} imageMatrix [description]\r\n   * @return {Array}             [description]\r\n   */\r\n  traceContours(imageMatrix)\r\n  {\r\n    let tracer = new _lib_FastContourTracer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](imageMatrix, BORDER_POINT);\r\n\r\n    imageMatrix.imageData = tracer.imageMatrix.imageData; // HACK: display manipulated image matrix.\r\n\r\n    return tracer.createPaths();\r\n  }\r\n\r\n  /**\r\n   * Create a canvas displaying imageData.\r\n   */\r\n  createCanvas(imageData)\r\n  {\r\n    let context = this.canvas.getContext('2d');\r\n\r\n    context.canvas.width  = imageData.width;\r\n    context.canvas.height = imageData.height;\r\n    context.canvas.imageSmoothingEnabled = false;\r\n    context.canvas.setAttribute(\"style\", \"border: 1px solid black;\");\r\n\r\n    context.putImageData(imageData, 0, 0);\r\n  }\r\n\r\n  /**\r\n   * Append element \\w canvas displaying contour data.\r\n   * @param  {HTMLElement} element [description]\r\n   */\r\n  toCanvas(canvas, scale = 1)\r\n  {\r\n    let i, j\r\n      , cpx, cpy\r\n      , path\r\n      , context = canvas.getContext(\"2d\");\r\n\r\n    //canvas.width  = this.S.width * scale;\r\n    //canvas.height = this.S.height * scale;\r\n\r\n    // Clear canvas\r\n    context.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    for (i = 0; i < this.paths.length; ++i)\r\n    {\r\n      context.beginPath();\r\n      path = this.paths[i].path;\r\n\r\n      for (j = 0; j < path.length; j += 2)\r\n      {\r\n        if (0 === j) {\r\n          context.moveTo(path[j] * scale, path[j + 1] * scale);\r\n        } else {\r\n          context.lineTo(path[j] * scale, path[j + 1] * scale);\r\n        }\r\n      }\r\n\r\n      // Close path if path indicates to do so.\r\n      if (true === this.paths[i].closed) {\r\n        context.closePath();\r\n      }\r\n\r\n      context.stroke();\r\n    }\r\n  }\r\n}\r\n\r\n// -----------------------------------------------------------------------------\r\n//\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Isoline);\r\n\n\n//# sourceURL=webpack://lib-apply/./lib/Isoline.js?");

/***/ }),

/***/ "./src/isoline.js":
/*!************************!*\
  !*** ./src/isoline.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_Isoline_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/Isoline.js */ \"./lib/Isoline.js\");\n\n\n\n// Handle change events\nlet eventHander = function(event)\n{\n  let no        = parseInt(this.dataset.example)\n    , threshold = parseInt(document.getElementById('threshold' + no).value)\n    , image     = document.getElementById('image' + no)\n    , canvas    = document.getElementById('canvas' + no);\n\n  if ( ! Number.isFinite(threshold)) {\n    throw new Error(\"No threshold found!\");\n  }\n\n  if ( ! canvas) {\n    throw new Error(\"No canvas found!\");\n  }\n\n  contour(threshold, image, canvas);\n}\n\n// Create isoline\nlet contour = function(threshold = 128, image = null, canvas = null)\n{\n  console.log(\"Isolinie mit Schwellwert: \" + threshold + \".\");\n\n  let iso  = new _lib_Isoline_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n\n  iso.fromImage(image, threshold);\n  iso.toCanvas(canvas, 2);\n}\n\nwindow.addEventListener('load', (event) => {\n\n  let img1, input1;\n\n  // IE detection:\n  if (detectedID > 0) {\n    $('div.alert-ie').css('display','inline-block');\n  }\n\n  img1 = document.getElementById('image1');\n  img1.addEventListener('load', eventHander.bind(img1));\n  //img1.src = \"./original.png\"\n  // HACK to prevent corss origin problems:\n  img1.src = \"data:image/png;base64,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\";\n\n  input1 = document.getElementById('threshold1');\n  input1.addEventListener('change', eventHander.bind(img1));\n});\n\n\n//# sourceURL=webpack://lib-apply/./src/isoline.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/isoline.js");
/******/ 	
/******/ })()
;